---
description: 值传递与引用传递
autoPrev: 全局异常处理

sidebarDepth: 1
---


## 背景
今天在公司做需求的时候，突然遇到了这个问题，八股文背过，但是又记不大清楚了。索性写下来，方便我这笨蛋脑子下次看。


## 解释
理解这个问题在于看它的**角度**（强调、加粗）

那我们开始，**Java中一切都是值传递**（中心句），基本变量传递的实际的值，比如 `int a=3`  会将 `3` 传递进去；引用变量传递的是地址，比如 `User user=new User()` 会将 user 所在的地址传递进去。

---
### 从 `角度` 来分析
所谓值传递，基本变量本身的 `值` 就是这里的值, 引用变量的 `地址` 就是这里的值。

> String 及包装类型也是值传递，因为这些对象不可变（Immutability）具体可参考：https://stackoverflow.com/questions/1552301/immutability-of-strings-in-java

---

### 从 `可见性` 来分析

基本变量：

先需要了解，局部变量会放在栈中，成员变量会放在堆中，如下图所示：

![](.\assets\值传递与引用传递\1704037-20231008191712122-666041907.png)


> 一个方法对应一个栈帧，方法结束后栈帧便会弹出

在上图中，test 方法栈帧感知不到 change 方法的变化，所以当 change 方法栈帧弹出后，test 方法依旧会输出 3 。

**引申一下**：现在一个公司需求 A系统、B系统 要同时操作一个数据，并要求实时感知数据变化，那我们可以怎么做？最简单的办法，加一个中间件，例如redis。需要注意数据一致性。

<br/>

引用变量：

如果是修改引用变量，那么便会修改堆中的数据，多个栈帧对应一个堆中对象，无论哪个方法修改了数据，其他方法再次访问都会感知变化。

![](.\assets\值传递与引用传递\1704037-20231008191721840-218593087.png)
